// lib/airtable.ts

import Airtable, { FieldSet } from 'airtable';

// Configure Airtable
const apiKey = process.env.AIRTABLE_API_KEY!;
const baseId = process.env.AIRTABLE_BASE_ID!;

Airtable.configure({ apiKey });
const base = Airtable.base(baseId);

// ────────────────────────────────────────────────────────────────────────────────
// Users table and helpers
// ────────────────────────────────────────────────────────────────────────────────

export const Users = base('Users');

function getEnv(): string {
  return process.env.NODE_ENV === 'production' ? 'production' : 'development';
}

export async function getUserRecord(
  uid: string
): Promise<Airtable.Record<FieldSet> | null> {
  const env = getEnv();
  const records = await Users.select({
    filterByFormula: `AND({UID}='${uid}',{Environment}='${env}')`,
    maxRecords: 1,
  }).firstPage();
  return records[0] || null;
}

export async function upsertAirtableUser({
  uid,
  email,
}: {
  uid: string;
  email: string;
}): Promise<void> {
  const env = getEnv();
  const fields = { UID: uid, Email: email, Environment: env };
  const existing = await getUserRecord(uid);
  if (existing) {
    await Users.update(existing.id, fields);
  } else {
    await Users.create(fields);
  }
}

// ────────────────────────────────────────────────────────────────────────────────
// SubscriptionPackages table and helpers
// ────────────────────────────────────────────────────────────────────────────────

export const SubscriptionPackages = base('SubscriptionPackages');

/**
 * Fetch all SubscriptionPackages for a given user.
 */
export async function getSubscriptionPackages(
  uid: string
): Promise<Airtable.Record<FieldSet>[]> {
  const userRec = await getUserRecord(uid);
  if (!userRec) return [];
  return SubscriptionPackages.select({
    filterByFormula: `{UID}='${uid}'`,
  }).firstPage();
}

/**
 * Fetch a single SubscriptionPackage by record ID.
 */
export async function getSubscriptionPackageById(
  id: string
): Promise<Airtable.Record<FieldSet> | null> {
  try {
    return await SubscriptionPackages.find(id);
  } catch {
    return null;
  }
}

/**
 * Fetch a single SubscriptionPackage by its slug.
 * (Slug field is now a Formula in Airtable.)
 */
export async function getSubscriptionPackageBySlug(
  slug: string
): Promise<Airtable.Record<FieldSet> | null> {
  const records = await SubscriptionPackages.select({
    filterByFormula: `{Slug}='${slug}'`,
    maxRecords: 1,
  }).firstPage();
  return records[0] || null;
}

/**
 * Create or update a SubscriptionPackage for a given user,
 * storing meeting, pricing, and slug details in one record.
 * (Slug is generated by Airtable Formula field, so we don't set it here.)
 */
export async function upsertSubscriptionPackage({
  uid,
  recordId,
  forceCreate,
  meetingTemplateId,
  Title,
  FirstSession,
  Recurring,
  Frequency,
  RRule,
  Price,
  Currency,
  Interval,
}: {
  uid: string;
  recordId?: string;
  forceCreate?: boolean;
  meetingTemplateId?: string | null;
  Title: string;
  FirstSession: string;   // ISO date-time string
  Recurring: boolean;
  Frequency: string;      // "None" | "Daily" | "Weekly" | "Monthly" | "Custom"
  RRule?: string;
  Price: number;          // in cents
  Currency: string;
  Interval: string;       // "One-off" | "Monthly" | "Yearly"
}): Promise<Airtable.Record<FieldSet>> {
  const userRec = await getUserRecord(uid);
  if (!userRec) {
    throw new Error(`No Airtable user record for UID: ${uid}`);
  }

  // Build fields payload (omit Slug; it's a formula field in Airtable)
  const fields: FieldSet = {
    UID: uid,
    Title,
    FirstSession,
    Recurring,
    Frequency,
    Price,
    Currency,
    Interval,
    Status: 'Draft',
    User: [userRec.id],
  };

  if (RRule) {
    fields.RRule = RRule;
  }
  if (meetingTemplateId) {
    fields.MeetingTemplate = [meetingTemplateId];
  }

  let record: Airtable.Record<FieldSet>;
  if (forceCreate || !recordId) {
    record = await SubscriptionPackages.create(fields);
  } else {
    await SubscriptionPackages.update(recordId, fields);
    record = await SubscriptionPackages.find(recordId);
  }

  return record;
}

// ────────────────────────────────────────────────────────────────────────────────
// Meetings table and helpers
// ────────────────────────────────────────────────────────────────────────────────

export const Meetings = base('Meetings');

/**
 * Fetch up to 10 upcoming meetings for a given subscription package,
 * but only those where the lookup field "UID" matches the userId.
 */
export async function getMeetingsForPackage(
  pkgId: string,
  userId: string
): Promise<Airtable.Record<FieldSet>[]> {
  return Meetings.select({
    filterByFormula: `AND(
      {SubscriptionPackage}='${pkgId}',
      {UID}='${userId}'
    )`,
    sort: [{ field: 'StartsAt', direction: 'asc' }],
    maxRecords: 10,
  }).firstPage();
}

/**
 * Return the single next upcoming Meeting for this package & user.
 */
export async function getNextMeetingForPackage(
  pkgId: string,
  userId: string
): Promise<Airtable.Record<FieldSet> | null> {
  const now = new Date().toISOString();
  const records = await Meetings.select({
    filterByFormula: `AND(
      {SubscriptionPackage}='${pkgId}',
      {UID}='${userId}',
      DATETIME_PARSE({StartsAt}) > DATETIME_PARSE('${now}')
    )`,
    sort: [{ field: 'StartsAt', direction: 'asc' }],
    maxRecords: 1,
  }).firstPage();

  return records[0] || null;
}

/**
 * Create a new Meeting record tied to a subscription package.
 */
export async function createMeetingForPackage(
  pkgId: string,
  startsAt: string
): Promise<Airtable.Record<FieldSet>> {
  return Meetings.create({
    SubscriptionPackage: [pkgId],
    StartsAt: startsAt,
  });
}
